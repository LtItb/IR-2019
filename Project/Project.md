
# Частное техническое задание

## ВВЕДЕНИЕ

<p style='text-align: justify;'>В данном частном техническом задании описана реализация веб-приложения – поисковой системы по базе фильмов.</p> 

<p style='text-align: justify;'> Приложение предложено реализовать на основе рассмотренной в ходе изучения курса платформы полнотекстового поиска Solr.</p>

<p style='text-align: justify;'>К использованию в качестве средств разработки рекомендуются язык Python 3.6, фреймворк Flask, библиотеки pysolr и React (для интерфейсной части).</p>

<p style='text-align: justify;'>Ниже приведено обоснование выбора средств разработки и платформы, а также более подробно описана реализация функций приложения.</p>

## 1. ВЫБОР СПП

Основу приложения составляет *система полнотекстового поиска* – поиска по содержимому документов. В качестве документов выступает информация о фильмах. 

Для реализации проекта выбрана система полнотекстового поиска Solr. 

*Solr* – платформа полнотекстового поиска с открытым исходным кодом, основанная на проекте Apache Lucene. Ее основные *возможности*: 
* полнотекстовый поиск;
* подсветка результатов;
* фасетный поиск;
* динамическая кластеризация;
* интеграция с базами данных;
* обработка документов со сложным форматом. 

Так как в Solr есть возможность распределенного поиска и репликации, Solr хорошо масштабируем. 

Основные *преимущества* Solr для использования при работе с Lucene: 
* скорость;
* оптимизация при работе с трафиком большого объёма;
* простота обращения и обработки результатов запросов (JSON, XML, HTTP);
* большое количество расширений и плагинов, созданных сообществом за многие годы развития этого open-source проекта.

## 2.  ВЫБОР СРЕДСТВ РАЗРАБОТКИ

Для реализации системы полнотекстового поиска необходимо использовать язык Python 3.6, фреймворк Flask и библиотеку pysolr. Для реализации интерфейсной части рекомендуется использовать React. 

[Python 3.6](https://docs.python.org/3.6/) – высокоуровневый кроссплатформенный язык программирования общего назначения, ориентированный на повышение производительности разработчика и читаемости кода. [Solr Python API](https://lucene.apache.org/solr/guide/7_3/using-python.html).

[Flask](http://flask.pocoo.org/docs/1.0/) – фреймворк для создания веб-приложений на языке программирования Python, использующий набор инструментов Werkzeug, а также шаблонизатор Jinja2. Относится к категории так называемых микрофреймворков – минималистичных каркасов веб-приложений, сознательно предоставляющих лишь самые базовые возможности.

[Pysolr](https://pypi.org/project/pysolr/) – легковесная обертка для Python для работы с Apache SOLR. Данная обертка содержит в себе такие базовые операции как: 
* выбор, обновление и удаление; 
* оптимизация индекса; 
* поддержка “More Like This”; 
* возможность коррекции ошибок при вводе.

[React](https://ru.reactjs.org/docs/getting-started.html) – JavaScript-библиотека с открытым исходным кодом для разработки пользовательских интерфейсов. React разрабатывается и поддерживается Facebook, Instagram и сообществом отдельных разработчиков и корпораций. React может использоваться для разработки одностраничных и мобильных приложений.

## 3. ОПИСАНИЕ РЕАЛИЗАЦИИ ФУНКЦИЙ

### 3.1. Структура приложения

#### 3.1.1. Колонки таблицы базы данных

* `id (text)` — уникальный идентификатор — id фильма на сайте imdb.com;
* `title (text)` — название фильма;
* `year (integer)` — год выхода фильма;
* `rating (float)` — пользовательский рейтинг фильма IMDB; 
* `genres (text[])` — жанр фильма; 
* `directors (text[])` — режиссер(ы) фильма;
* `release_dates (text[])` — даты выхода фильма по странам;
* `top_3_cast (text[])` — 3 первые записи из актерского состава фильма;
* `storyline (text)` — аннотация;
* `synopsis (text)` — синопсис.

Необходимо одготовить скрипт для индексации базы данных. При индексировании данных учесть, что несколько полей являются массивами.

#### 3.1.2.  Общая структура поисковых запросов

Для организации обмена между клиентской и серверной частью приложения предлагается следующая структура запросов и ответов:

структура запроса: 

`{“query” : “query example”, 
“params” : [“param1” : value1, “param2” : value2]}`;

структура ответа: 

`{“success” : true, 
“result” : [“film1” : {
	“id” : “id”,
	“title” : “filmName1”, 
	“year” : 1900, 
	“rating” : 5.5, 
	“genres” : [“genre1”, “genre2”], 
	“directors” : [“director1”, “director2”], 
	“releaseDates” : [“releaseDate1”, “releaseDate2”], 
	“top3Cast” : [“actor1”, “actor2”, “actor3”], 
	“storyline” : “example storyline”, 
	“synopsis” : “example synopsis”
	}, 
	“film2” : {...},
...]
}`,

где `“query”` – строка – служит для передачи текста поискового запроса, массив `“params”` содержит параметры поиска (описаны отдельно для каждой функции), `“success”` – флаг (булевая переменная), указывающий на успешность выполнения запроса, `“result”` – массив объектов – полученный результат запроса. 

Такая структура будет общей для всех поисковых запросов, для других типов запросов структура предложена отдельно как часть описания реализации соответствующих функций. Предлагается ограничить количество возвращаемых результатов поиска десятью наиболее релевантными объектами.

В дальнейшем при описании функций в качестве выходных данных будет представлено значение свойства `“result”`.

#### 3.1.3. Интерфейс приложения

Примерное расположение элементов на главной странице приложения приведено на рисунке 1. 

<p align="center">
    <img src="https://github.com/baevvi/IR-2019/blob/master/Project/Images/img1.png">
</p>

По нажатию на один из результатов поиска в модальном окне отображается подробная информация о фильме и похожие варианты (подробнее в описании функции MoreLikeThis). Пример данного окна изображен на рисунке 2.

<p align="center">
    <img src="https://github.com/baevvi/IR-2019/blob/master/Project/Images/img2.png">
</p>

### 3.2. Бустинг

В реализуемом приложении предложено использовать бустинг во время выполнения запроса. 

*Поиск без применения бустинга* должен быть представлен общей поисковой строкой в клиентском интерфейсе приложения. 

*Поиск с бустингом* по полю представлен в клиентском интерфейсе набором “флажков” (checkbox) внутри мультиселектора с возможностью включения учета последовательности полей. Поля для бустинга: 
* название фильма; 
* рейтинг;
* жанры; 
* режиссеры;
* актеры; 
* аннотация;
* синопсис.

Для реализации иерархии полей для поиска (выше поле – сильнее бустинг) сделать селектор с возможность перетаскивания (drag-n-drop).

*Бустинг терминов* должен быть реализован кавычками в поисковой строке.

Требуется реализовать Query Time Boosting без переиндексации документов.

**Входные данные:** поисковый запрос – строка, названия полей (строки) и веса бустинга (числа с плавающей точкой). Объект вида: 

`{“query” : “текст запроса”, “params”: [“boostingFields” : [“fieldName1”: fieldWeight1, “fieldName2” : fieldWeight2]]}`.

**Выходные данные** (`“result”`): результат поискового запроса – массив информации о фильмах вида:

`[“film1” : {
	“id” : “id”,
	“title” : “filmName1”, 
	“year” : 1900, 
	“rating” : 5.5, 
	“genres” : [“genre1”, “genre2”], 
	“directors” : [“director1”, “director2”], 
	“releaseDates” : [“releaseDate1”, “releaseDate2”], 
	“top3Cast” : [“actor1”, “actor2”, “actor3”], 
	“storyline” : “example storyline”, 
	“synopsis” : “example synopsis”
            }, 
  “film2” : {...},
 ...]`,

отсортированный по Score, полученному после запроса с использованием бустинга.

### 3.3. Подсвечивание результатов

Реализовать выделение поискового запроса в результатах путем изменения цвета фона текста запроса на отличный от фона окна выдачи результата и цвета шрифта.

**Входные данные**: поисковый запрос и результат.

**Выходные данные**: в окне результатов выделены вхождения точной цитаты поискового запроса.

Реализуется полностью на стороне клиентского интерфейса.

### 3.4. Спонсорский поиск

Для добавления новых фильмов к спонсируемым необходимо реализовать отдельное окно/вкладку с возможностью получить список фильмов по названию и году, после чего выбрать спонсируемый фильм из полученных результатов (см. рисунок 3). 
ID выбранного фильма отправить для добавления в список спонсируемых фильмов после выбора фильма из списка пользователем.

<p align="center">
    <img src="https://github.com/baevvi/IR-2019/blob/master/Project/Images/img3.png">
</p>

При реализации поиска фильмов для добавления к спонсорским и самого добавления предлагается следующая структура запросов.

**Входные данные** – текст запроса (название и/или год):

`{“query” : “superman 1978”}`.

**Выходные данные** – список фильмов для дальнейшего выбора и добавления в перечень спонсируемых:

`{“success” : true, 
  “result”  :  
    [“film1” : {“title1”, “id1”, “year1”}, 
     “film2” : {“title2”, “id2”, “year2”}]
 }`.
 
Для реализации спонсорского поиска используется компонента Query Elevation с параметром enableElevation для включения/отключения функции спонсорской выдачи.

Спонсированные результаты должны отмечаться в окне выдачи меткой “Ad:”.

**Входные данные** – поисковый запрос и метка enableElevation (true/false):

`{“query” : “query example”, “params” : [“enableElevation” : true]}`.

**Выходные данные** – массив данных о фильмах с метками “elevated” (true/false):

`[“film1” : 
		{“title” : “filmName1”, 
		 “year” : 1900, 
		 “rating” : 5.5, 
		 “genres” : [“genre1”, “genre2”], 
		 “directors” : [“director1”, “director2”], 
		 “releaseDates” : [“releaseDate1”, “releaseDate2”], 
		 “top3Cast” : [“actor1”, “actor2”, “actor3”], 
		 “storyline” : “example storyline”, 
		 “synopsis” : “example synopsis”, 
		 “elevated” : true}, 
  “film2”: 
		{...},
 ...]`.

### 3.5. Автоподстановка

Автоподстановка позволяет пользователю сократить время на ввод запроса, за счет выбора из предлагаемых системой вариантов его завершения. Начиная с ввода трех символов пользователю предлагаются варианты завершения его запроса из названий фильмов.

Реализовать Single Term Suggestions ([пример реализации](https://blog.griddynamics.com/implementing-autocomplete-with-solr/)).

**Входными данными** является поисковый запрос – строка с параметром "искать только по названиям": 

`{“query” : “aveng”, “params”:[“searchTitlesOnly” : true]}`.

**Выходные данные** (`“result”`) – массив из трех вариантов названий фильмов для завершения пользовательского запроса – строки:

`[“Avengers: Endgame”, “Avengers: Age of Ultron”, “Avengers: Infinity War”].`

### 3.6. Query Re-Ranking

Query Re-Ranking применяется для более высокой выдачи определенных (релевантных) результатов запроса. 

В рамках выполнения проекта предлагается  поднять в списке выдачи фильмы с рейтингом больше 6.0.
Реализуется путем указания параметра rq при составлении запроса.

**Входные данные**: поисковый запрос – строка (дополнительные параметры не требуются).

**Выходные данные**: отсортированные результаты поиска – массив объектов (пример в описании предыдущих функций).

### 3.7. Группировка результатов 

Реализовать группировку результатов по выбранному полю/полям. Поле должно выбираться из селектора на странице (см. рисунок 1). Выдача должна выглядеть как значение группирующего поля и список полученных результатов.

**Входные данные** – строка поиска и поля для группировки результатов:

`{“query” : “example query”, “params”: [“groupBy” : [“title”, “year”]}`.

**Выходные данные** – значение поля группировки + сгруппированный массив результатов поиска:

`[“groupedTitle1” : [
		“groupedYear1” : [
			{“title1”, “year1”, “rating1”, ...}, 
			{“title1”, “year1”, “rating2”, ...}, 
            ...
		], 
		“groupedYear2” : [
			{“title1”, “year2”, “rating3”, ...},
			{"title1", "year2", "rating4", ...},
            ...
		], ...
	], 
  “groupedTitle2” : [
		“groupedYear1” : [
			{“title2”, “year1”, “rating5”, ...},
			{"title2", "year1", "rating6", ...},
			...
		], 
		“groupedYear2” : [
            {“title2”, “year2”, “rating7”, ...},
			{"title2", "year2", "rating8", ...},
			...
		], ...
     ], 
...]
`.

### 3.8. MoreLikeThis

При открытии модального окна с подробной информацией идентификатор выбранного фильма отправляется для получения списка похожих фильмов, количество результатов для вывода ограничено тремя. Результат – краткая информация о похожих фильмах (название, год, жанры, актеры, режиссеры, рейтинг) – выводится в специальной секции карточки фильма (см. рисунок 2).

Используется компонента MoreLikeThisComponent.

**Входные данные**: 

`{“id” : “id”, “params” : [“getMLT” : true]}`.

**Выходные данные** – подходящие MLT фильмы и метка успешности запроса: 

`{“success” : true”, 
   “result” : [
		“film1” : {
			“id” : “0000001”,
			“title” : “title1”, 
			“year” : 1900, 
			“rating” : 5.5, 
            “genres” : [“genre1”, “genre2”], 
			“directors” : [“director1”, “director2”],
			“top3Cast” : [“actor1”, “actor2”, “actor3”],
		“film2” : {...}, 
		“film3” : {...}
     ]
 }
`.


### 3.9. SpanQueries

Реализовать обработку двух синтаксисов запросов.

*Указание слов и их позиций в полях документа*:

`{number1: “word1”, number2: ”word2”}`,

где `number1` и `number2` – порядковый номер слова в желаемом результате, `”word1”` и `”word2”` – искомые слова в указанных позициях.

*Указание расстояния между искомыми словами*:

`word1 <spanLength> word2`,

где `word1` и `word2` – искомые слова, а `spanLength` – расстояние между ними.

**Входные данные** – поисковый запрос с особым синтаксисом:

`{“query”:”{1:’movieWord1’, 2:’movieWord2’}”}`

**Выходные данные**: массив результатов поиска (приведен в примерах выше).

## 4. РАСШИРЯЕМОСТЬ СЕРВИСА

Расширяемость реализуется путем добавления элементов в интерфейсной части приложения, а также функций и скриптов для обработки запросов.

К примеру, для добавления функционала по получению информации о тональности текста с целью подбора схожих “по настроению” фильмов (смешной/романтичный/страшный) в базу следует добавить колонку и внести соответствующие значения. После этого функция поиска модифицируется следующим образом: путем отправки сервису текста поискового запроса пользователя (search query) получается искомое(-ые) значение(-я) тональности, с которым(-и) сравниваются значения в базе. На главную страницу приложения и в инструкцию пользователя добавляется информация о наличии в веб-приложении нового функционала.

##  5. СИСТЕМА РАСПРОСТРАНЕНИЯ

Необходимо развернуть веб-приложение на хостинге. Серверная часть веб-приложения размещена на том же хостинге. Отказоустойчивость реализуется средствами хостинга.

Реализация проекта в качестве веб-приложения позволяет работать с приложением с большинства современных платформ.

## 6. ТРЕБОВАНИЯ К АППАРАТНОМУ ОБЕСПЕЧЕНИЮ И СИСТЕМНОМУ ПО

### 6.1. Требования к клиенту

| Устройство   | ОС                | Браузер                                         |
| :----------: | :---------------: | :---------------------------------------------: |
| ПК           | Windows 7         | Internet Explorer 11 <br> Google Chrome 72 или выше |
| &#xfeff;     | Windows 8.1       | Internet Explorer 11 <br> Google Chrome 72 или выше |
| &#xfeff;     | Windows 10        | Internet Explorer 11 <br> Microsoft Edge 44 или выше <br> Google Chrome 72 или выше |
| Mac          | macOS High Sierra | Google Chrome 72 или выше                       |
| &#xfeff;     | macOS Mojave      | Google Chrome 72 или выше                       |

### 6.2. Требования Apache Solr

Минимальные требования Apache Solr приведены в таблице ниже.

| Параметр            | Требования |
| :-----------------: | :--------: |
| Операционная система| Windows Server 2012 (64bit) <br> Windows Server 2012 R2 (64bit) <br> Windows Server 2016 (64bit) <br >Red Hat Enterprise Linux 6.x (64bit) <br> Red Hat Enterprise Linux 7.x (64bit)|
| CPU                 | Достаточный для стабильной работы установленной ОС <br> (или процессор с частотой 3GHz)|
| Оперативная память  | Рекомендуется не менее 2 GB |
| Жесткий диск        | 100 MB + объем данных в БД |
|База данных          |Oracle Database 12c Release 1 <br> Oracle Database 12c Release 2 <br> Oracle Database 18c <br> PostgreSQL 9.4 <br> PostgreSQL 9.5 <br> PostgreSQL 9.6 <br> PostgreSQL 10 <br> PostgreSQL 11 <br> Microsoft SQL Server 2012 <br> Microsoft SQL Server 2014 <br> Microsoft SQL Server 2016 <br> Microsoft SQL Server 2017|

Для хранения информации о 16616 фильмах с использованием СУБД PostgreSQL достаточно 100 мегабайт (в среднем 6 килобайт/фильм * 16616 фильмов).

Более точные требования для стабильной работы системы под нагрузкой определяются на этапе тестирования.
